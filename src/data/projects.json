[
  {
    "slug": "receipt-ocr-transactions",
    "title": "Receipt OCR",
    "caption": "Structured Transactions",
    "coverImageUrl": "/covers/receipt-ocr.jpg",
    "shortDescription": "Image in -> PaddleOCR on Cloud Run -> receipt-shaped text -> fast JSON extraction; ~200% OCR speed-up vs earlier approach.",
    "description": "Built a receipt OCR pipeline where images are sent to a CPU PaddleOCR service running in Docker on Google Cloud Run. PaddleOCR returns text with bounding boxes/positions, then a reconstruction function rebuilds a receipt-shaped text string that preserves layout cues. That reconstructed text lets a lightweight text-only LLM extract structured JSON quickly, without needing a slower multimodal model for OCR. Result: roughly a 200% OCR speed increase versus the earlier prototype path.",
    "longDescription": "Designed a two-stage receipt extraction pipeline optimized for speed and cost. Stage 1 runs PaddleOCR (CPU, Docker, Cloud Run) to convert receipt images into text plus bounding box coordinates. Stage 2 uses those coordinates to reconstruct a receipt-like text block so line order and visual grouping are preserved well enough for parsing. Feeding this reconstructed text to a small text-only LLM makes JSON extraction fast and reliable, so multimodal LLM OCR is optional instead of required. Compared to the initial approach, OCR throughput improved by about 200%.",
    "year": "2025",
    "stack": [
      "Python",
      "PaddleOCR",
      "Cloud Run",
      "Docker",
      "GCP",
      "LLM"
    ],
    "valueProp": "Fast, low-cost receipt-to-JSON extraction: OCR on Cloud Run plus layout reconstruction enables small-LLM parsing without multimodal overhead.",
    "status": "Prototype",
    "highlights": [
      "~200% OCR speed improvement over the earlier prototype approach",
      "PaddleOCR runs on CPU in a Docker container hosted on Cloud Run",
      "OCR output includes text plus bounding boxes/positions for each token",
      "Reconstruction step rebuilds receipt-shaped text from OCR coordinates",
      "Layout-preserving text enables fast JSON extraction with a small text LLM"
    ],
    "architectureSteps": [
      "Upload Image",
      "PaddleOCR (Cloud Run)",
      "Get Text + Boxes",
      "Reconstruct Receipt Text",
      "LLM JSON Extraction (Optional)",
      "Return JSON"
    ],
    "architectureNotes": [
      "Cloud Run hosts PaddleOCR in a CPU Docker container for fast image-to-text conversion",
      "Bounding boxes are used to rebuild a receipt-like string that preserves rough visual layout",
      "Because the LLM receives structured text instead of raw images, a small non-multimodal model can extract JSON quickly",
      "Future production scale: run on an always-on VM (no cold starts) with GPU-backed local LLM serving for security, lower latency, and control"
    ],
    "challenges": [
      "Noisy, skewed, and low-light receipt images",
      "Parsing line items across different merchant layouts",
      "Cold starts on Cloud Run due to model load time",
      "Balancing latency, accuracy, and Cloud Run cost"
    ],
    "results": [
      {
        "label": "OCR speed",
        "value": "~200% faster vs earlier prototype path"
      },
      {
        "label": "Pipeline design",
        "value": "OCR with spatial reconstruction before LLM parsing"
      },
      {
        "label": "Model strategy",
        "value": "Avoids multimodal LLM OCR on the hot path"
      },
      {
        "label": "Latency profile",
        "value": "Optimized for low-latency receipt-to-JSON extraction"
      }
    ],
    "nextSteps": [
      "Move OCR service to an always-on VM at higher traffic to eliminate cold starts",
      "Use a GPU machine to accelerate OCR/serving and reduce end-to-end latency",
      "Self-host a lightweight local LLM (for example, Ollama) instead of external API calls for better security and customization",
      "Adopt GPU/self-hosted serving when traffic justifies infrastructure cost"
    ],
    "screenshots": [
      {
        "src": "/media/receipt-ocr-img1.jpg",
        "type": "image",
        "caption": "Receipt OCR pipeline output preview"
      }
    ],
    "tags": [
      "Python",
      "OCR",
      "LLM",
      "GCP"
    ],
    "repoUrl": null,
    "demoUrl": {
      "label": "Preview (Google Cloud Run)",
      "url": "https://receipt-ocr-demo-944565818393.us-central1.run.app/"
    },
    "featured": true,
    "category": "ml-ai"
  },
  {
    "slug": "ti84-wireless-messaging",
    "title": "TI-84 Wireless Messaging",
    "caption": "Embedded calculator messaging system",
    "coverImageUrl": "/covers/ti84-wireless-messaging.jpg",
    "shortDescription": "Embedded an Arduino Nano + nRF24L01 inside TI-84 calculators to enable low-latency wireless multi-user chat.",
    "description": "Built a hardware-software messaging system by embedding an Arduino Nano and nRF24L01 RF transceiver inside TI-84 calculators. Reverse-engineered the TI-84 TRS link behavior and implemented a bridge between TI-BASIC UI flows and Arduino firmware packet handling for real-time wireless chat.",
    "longDescription": "Designed and built an end-to-end wireless messaging stack for TI-84 calculators. Hardware integration included Arduino Nano, nRF24L01 transceiver, wiring, capacitors for power stability, a mini I/O switch, and internal assembly/soldering inside the calculator shell. Software work included TI-BASIC client UX plus Arduino C/C++ firmware for framing, retries, and message delivery across multiple devices. The system achieved stable real-world messaging while operating under strict power, space, and timing constraints.",
    "motivation": "I noticed TI-84 calculators have TRS link ports and started digging into what they could do. After learning they are mainly used to share charts/data, I found a driver online that let TI-BASIC read from and write to the TRS cable directly. That inspired me to build a minimal chat interface and message protocol. The key idea was simple: if I can transmit messages over a wire, I can replace the wire with RF and make calculator-to-calculator wireless messaging.",
    "year": "2020",
    "stack": [
      "Arduino Nano",
      "nRF24L01 Transceiver",
      "TI-BASIC",
      "Arduino C/C++",
      "Capacitors & wiring",
      "Mini I/O switch",
      "Soldering + assembly"
    ],
    "valueProp": "Turn stock TI-84 calculators into portable wireless chat devices with custom embedded hardware and firmware.",
    "status": "Prototype",
    "highlights": [
      "Reverse-engineered TI-84 link behavior to bridge calculator I/O with Arduino firmware",
      "Embedded Arduino Nano + nRF24L01 hardware inside the calculator enclosure",
      "Added power conditioning (capacitors) and switch control for reliable operation",
      "Built TI-BASIC chat UI with Arduino-side packet handling and retries"
    ],
    "nextSteps": [
      "Measure battery impact and optimize idle/runtime power draw",
      "Improve message history and ergonomics in the TI-BASIC interface",
      "Design a cleaner internal mounting approach for repeatable assembly"
    ],
    "screenshots": [
      {
        "src": "/media/ti84-wireless-mov1.mp4",
        "type": "video",
        "caption": "TI-84 wireless messaging demo"
      }
    ],
    "tags": [
      "Arduino",
      "C/C++",
      "TI-BASIC",
      "Embedded"
    ],
    "repoUrl": null,
    "demoUrl": {
      "url": "https://www.reddit.com/r/ti84hacks/comments/f5k8x1/wireless_communication/"
    },
    "featured": true,
    "category": "school",
    "architectureSteps": [
      "TI-BASIC Input",
      "Serial/TRS Bridge",
      "Packet Encode",
      "RF Tx/Rx (nRF24L01)",
      "Message Parse",
      "Chat Render"
    ],
    "architectureNotes": [
      "Calculator UI runs in TI-BASIC while Arduino firmware handles transport and reliability logic",
      "nRF24L01 provides low-latency wireless transfer between modified calculators",
      "Capacitors and careful wiring reduced power noise/reset issues in a tight enclosure",
      "Mechanical assembly used soldering and hot glue for routing and strain relief"
    ],
    "challenges": [
      "Very limited internal space for wiring, switch placement, and RF module fit",
      "Power instability and noise inside a constrained calculator power budget",
      "Reliable message transfer under packet loss/interference constraints",
      "Keeping on-calculator chat UX usable within TI-BASIC limitations"
    ],
    "results": [
      {
        "label": "System outcome",
        "value": "Working multi-calculator wireless chat prototype"
      },
      {
        "label": "Reliability approach",
        "value": "Firmware-level packet framing, retries, and parsing"
      },
      {
        "label": "Hardware integration",
        "value": "Internal Nano + nRF24L01 + conditioned power delivery"
      },
      {
        "label": "End-to-end scope",
        "value": "Reverse engineering, soldering, firmware, and TI-BASIC UX"
      }
    ],
    "references": [
      {
        "label": "Merthsoft TI-83+/84+ Link Guide",
        "href": "https://merthsoft.com/linkguide/ti83+/index.html",
        "note": "Primary reference used to understand the link protocol and shape the message transport implementation."
      }
    ]
  },
  {
    "slug": "miro-smlm-clustering",
    "title": "SMLM Clustering with Graph Embeddings",
    "caption": "SFU / MIRO-based pipeline",
    "coverImageUrl": "/covers/smlm-clustering.jpg",
    "shortDescription": "Built an SMLM clustering pipeline using MIRO graph embeddings and density-based clustering.",
    "description": "Built a single-molecule localization microscopy (SMLM) clustering pipeline using MIRO graph embeddings and DBSCAN/HDBSCAN. Reproduced and trained MIRO on custom SMLM localization data and evaluated how embedding choices affect recovered molecular structures.",
    "longDescription": "Built an SMLM (single-molecule localization microscopy) clustering pipeline using MIRO-based graph embeddings and density-based clustering at SFU. Reproduced and trained MIRO on custom SMLM localization data using mutual k-NN graphs. Identified molecular structures via DBSCAN/HDBSCAN and reconstruction outputs.",
    "year": "2025",
    "stack": [
      "Python",
      "PyTorch",
      "MIRO",
      "DBSCAN",
      "HDBSCAN"
    ],
    "valueProp": "Cluster single-molecule localization microscopy data using MIRO graph embeddings and density-based clustering.",
    "status": "Research project",
    "highlights": [
      "Reproduced and trained MIRO on custom SMLM datasets",
      "Used mutual k-NN graphs to build input representations",
      "Evaluated how embedding choices affect recovered structures"
    ],
    "nextSteps": [
      "Scale experiments across larger SMLM datasets",
      "Automate hyperparameter sweeps for clustering and embeddings"
    ],
    "tags": [
      "Python",
      "PyTorch",
      "ML",
      "HDBSCAN"
    ],
    "repoUrl": {
      "url": "https://github.com/sfu-cmpt340/2025_3_project_14"
    },
    "demoUrl": null,
    "featured": true,
    "category": "bio",
    "categories": [
      "bio",
      "ml-ai",
      "school"
    ]
  },
  {
    "slug": "auto-sales-pdf-automator",
    "title": "Auto Sales PDF Automator",
    "caption": "Sherwood Park Toyota",
    "coverImageUrl": "/covers/auto-sales-pdf-automator.jpg",
    "shortDescription": "Automated dealership PDF paperwork from structured customer and vehicle data.",
    "description": "Automated PDF paperwork generation for a high-volume auto dealership by mapping structured customer and vehicle data into standardized form templates. Added validation for required fields, dates, and pricing to cut manual re-entry and reduce errors in day-to-day workflows.",
    "longDescription": "Automated PDF paperwork generation from structured customer and vehicle data for Sherwood Park Toyota, AB. Programmatic PDF form filling mapped to standardized document templates. Implemented validation and normalization (required fields, dates, pricing, input cleanup) to prevent errors. Consolidated multi-form manual entry into a single streamlined input workflow.",
    "year": "2025",
    "stack": [
      "Python",
      "PDF form filling",
      "Automation"
    ],
    "valueProp": "Generate clean dealership PDFs automatically from structured customer and vehicle data.",
    "status": "Client project",
    "highlights": [
      "Mapped structured customer and vehicle data into standardized PDF templates",
      "Added validation for required fields, dates, and pricing",
      "Collapsed multi-form manual entry into one streamlined workflow"
    ],
    "nextSteps": [
      "Add monitoring around error rates and form rejection reasons",
      "Expose a simple API for other dealership tools to generate paperwork"
    ],
    "tags": [
      "Python",
      "PDF",
      "Automation"
    ],
    "repoUrl": null,
    "demoUrl": null,
    "featured": true,
    "category": "freelance"
  },
  {
    "slug": "transaction-spending-tracker",
    "title": "Transaction & Spending Tracker",
    "caption": "Multi-source finance dashboard",
    "shortDescription": "Built a finance dashboard that ingests transactions from multiple sources and aggregates spending by time and timezone.",
    "description": "Built a React-based finance dashboard that ingests transactions from multiple sources and aggregates spending by day, week, and month across timezones. Designed data models and APIs to support flexible filtering and CSV-style exports for deeper analysis.",
    "longDescription": "Built a finance app to ingest and track transactions and spending across multiple sources. Implemented dynamic aggregation logic by time resolution and timezone (e.g., daily/weekly/monthly rollups). Designed data models and APIs to support flexible grouping and querying over large transaction histories.",
    "year": "2025",
    "tags": [
      "React",
      "JavaScript",
      "Finance",
      "Data"
    ],
    "repoUrl": null,
    "demoUrl": null,
    "featured": false,
    "category": null
  },
  {
    "slug": "celestia-affirmations-astrology",
    "title": "Celestia",
    "caption": "Astrology + Daily Affirmations App",
    "shortDescription": "Co-designed a mobile app concept that combines daily affirmations with personalized astrology content.",
    "description": "Co-designed and prototyped Celestia, a mobile app that combines daily affirmations with personalized astrology content. Built Explore and content discovery UI (including a Masonry-style grid bottom sheet) and explored subscription and token-based content unlock models.",
    "longDescription": "Co-developed \"Celestia,\" a mobile app concept combining daily affirmations and astrology content. Designed feature set and monetization options (subscriptions/tokens/content unlocks) and planned modular content delivery. Built and implemented UI work like an Explore bottom sheet with a Masonry grid layout; explored enhancements like category captions and interaction polish.",
    "year": "2025",
    "tags": [
      "React Native",
      "Mobile",
      "UI/UX",
      "Product"
    ],
    "repoUrl": null,
    "demoUrl": null,
    "featured": false,
    "category": "school"
  },
  {
    "slug": "protein-pdb-viewer",
    "title": "PDB Structure Viewer",
    "caption": "Secondary structure handling",
    "shortDescription": "Prototyped a browser-based viewer for PDB files with helix/sheet visualization and secondary-structure annotations.",
    "description": "Prototyped a browser-based PDB structure viewer that renders helices and sheets and overlays secondary-structure annotations. Explored frontend vs backend approaches for parsing PDB data and evaluated performance trade-offs for interactive visualization.",
    "longDescription": "Prototyped a structure viewer workflow around PDB data, exploring how to represent helices/sheets and annotate structures. Evaluated frontend vs backend approaches for secondary-structure extraction and rendering performance.",
    "year": "2025",
    "tags": [
      "JavaScript",
      "PDB",
      "Visualization",
      "Bioinformatics"
    ],
    "repoUrl": null,
    "demoUrl": null,
    "featured": false,
    "category": "bio"
  },
  {
    "slug": "chat-streaming-haptics",
    "title": "Streaming Haptics Trigger",
    "caption": "Haptics on stream start",
    "shortDescription": "Added haptic feedback when chat message streaming begins to make the UI feel more responsive.",
    "description": "Implemented a UX improvement that triggers haptic feedback when chat message streaming begins, making the interface feel more responsive and alive. Tuned timing and intensity so the effect is noticeable but not distracting.",
    "longDescription": "Implemented a UX improvement: trigger haptic feedback when chat message streaming starts.",
    "year": "2025",
    "tags": [
      "UX",
      "Mobile",
      "Haptics"
    ],
    "repoUrl": null,
    "demoUrl": null,
    "featured": false,
    "category": "mini"
  },
  {
    "slug": "haulr-concrete-fleet",
    "title": "Haulr",
    "caption": "Concrete Ordering & Fleet Management Dashboard",
    "shortDescription": "Built a React + shadcn/ui dashboard for concrete ordering and delivery coordination.",
    "description": "Built a customer-facing dashboard for concrete ordering and delivery coordination using React and shadcn/ui. Designed domain-specific controls for slump and set-delay/retarder dosage and mirrored real dispatch workflows so customers and ops see the same state.",
    "longDescription": "Haulr is a concrete ordering and fleet management app with a customer dashboard UI, built around letting customers specify concrete mix and delivery requirements and managing deliveries and trucks on the ops side. Built the customer-facing dashboard with React and shadcn/ui (Tailwind + Radix-style components). Designed concrete \"slump\" input UI with quick-select pills for common values (e.g. 25–200 mm) plus \"Other\" numeric input and helper text; and set delay/retarder dosage input expressed as % of cement weight (0–3%, 0.1% steps) with the same preset + \"Other\" pattern. Dev workflow used VS Code and GitHub Copilot with AI-assisted scaffolding for components, forms, validation, and dashboard UI; explored a custom MCP server so Copilot/AI tools could generate code aware of Haulr-specific data and logic (job lists, truck locations, Firebase operations).",
    "year": "2025",
    "tags": [
      "React",
      "shadcn/ui",
      "Tailwind",
      "Dashboard"
    ],
    "repoUrl": null,
    "demoUrl": null,
    "featured": false,
    "category": "freelance"
  },
  {
    "slug": "meiro-tigan",
    "title": "Meiro Tigan",
    "caption": "Lead gen website for concrete contractor",
    "coverImageUrl": "/covers/meirotigan.jpg",
    "shortDescription": "Built a responsive lead-gen site and quote form for a concrete contractor in the Lower Mainland.",
    "description": "Built a responsive lead-generation website for Meiro Tigan, a concrete contractor in the Lower Mainland. Implemented service pages and a quote/contact flow that routes inquiries to email/CRM, with mobile-first layouts for homeowners browsing on phones.",
    "longDescription": "Built a responsive business website for Meiro Tigan, a concrete and construction services company (foundations, slabs, driveways) serving the Lower Mainland and surrounding areas. Implemented service pages, contact/quote flow, and mobile-first UX to drive leads and quote requests; deployed with modern web tooling.",
    "year": "2025",
    "tags": [
      "React",
      "Web",
      "Responsive",
      "Lead gen"
    ],
    "screenshots": [
      {
        "src": "/covers/meirotigan.jpg",
        "alt": "Meiro Tigan website homepage",
        "caption": "Homepage hero and lead-generation layout."
      }
    ],
    "repoUrl": null,
    "demoUrl": {
      "url": "https://meirotigan.com"
    },
    "featured": false,
    "category": "freelance"
  },
  {
    "slug": "bc-ferries-terminal-booker",
    "title": "Ferry Terminal Booker",
    "caption": "File-backed reservation system (C)",
    "coverImageUrl": "/covers/ferry-terminal-booker.jpg",
    "shortDescription": "Built a C-based terminal reservation system for a mock BC Ferries client using file storage (no database) with search, edit/delete, payments, and occupancy checks.",
    "description": "Built a ferry terminal booking system in C for a mock client (BC Ferries) as a school group project. Implemented file-backed persistence (no database) for customers, reservations, and payments. Supports creating customers, taking payments, checking sailing occupancy, and full reservation management (search, edit, delete).",
    "longDescription": "Built a terminal-based ferry booking and reservation manager in C for a mock client (BC Ferries) as a school group project. Data is persisted using flat-file storage rather than a database, requiring careful record layouts, validation, and update patterns for edits and deletes. Implemented customer creation, reservation creation and lookup (by customer and reservation fields), edit/delete flows, payment capture, and occupancy checks to prevent overbooking. Designed the CLI menus and input validation to keep workflows fast for an operator at a terminal counter.",
    "year": "2025",
    "stack": [
      "C",
      "File I/O",
      "Data serialization",
      "CLI"
    ],
    "valueProp": "Manage ferry customers, reservations, payments, and occupancy in a fast terminal workflow—backed by flat-file storage.",
    "status": "School project",
    "highlights": [
      "Implemented file-backed persistence for customers, reservations, and payments (no database)",
      "Built search flows to find reservations and customers quickly from terminal menus",
      "Supported full reservation lifecycle: create, edit, delete, and payment capture",
      "Added occupancy checks to prevent overbooking on sailings"
    ],
    "architectureSteps": [
      "Menu UI",
      "Validate Input",
      "Read Files",
      "Apply Update",
      "Write Back",
      "Report/Receipt"
    ],
    "architectureNotes": [
      "Records are stored in flat files with explicit parsing/serialization logic",
      "Edits/deletes handled via safe rewrite patterns to avoid corrupting stored data",
      "Occupancy derived from reservation records to enforce capacity constraints"
    ],
    "challenges": [
      "Keeping file updates safe and consistent without a database transaction layer",
      "Designing record formats that support lookup + edits without becoming brittle",
      "Ensuring input validation prevents invalid states (dates, capacities, payment totals)"
    ],
    "results": [
      {
        "label": "Persistence",
        "value": "Flat-file storage (no DB)"
      },
      {
        "label": "Core features",
        "value": "Search, edit/delete, payments, occupancy checks"
      },
      "Supports customer creation and reservation management end-to-end via CLI"
    ],
    "nextSteps": [
      "Add automated tests for parsing/serialization and update flows",
      "Introduce an indexing file to speed up reservation searches",
      "Add export/report generation for daily sailings and revenue summaries"
    ],
    "tags": [
      "C",
      "File I/O",
      "CLI",
      "School"
    ],
    "repoUrl": {
      "url": "https://github.com/zacharydagameiro/Ferry"
    },
    "demoUrl": null,
    "featured": false,
    "category": "school"
  }
]
